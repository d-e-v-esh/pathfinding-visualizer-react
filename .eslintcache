[{"C:\\Users\\Devesh\\Documents\\React_Projects\\pathfinding-visualizer-react\\src\\index.js":"1","C:\\Users\\Devesh\\Documents\\React_Projects\\pathfinding-visualizer-react\\src\\reportWebVitals.js":"2","C:\\Users\\Devesh\\Documents\\React_Projects\\pathfinding-visualizer-react\\src\\App.js":"3","C:\\Users\\Devesh\\Documents\\React_Projects\\pathfinding-visualizer-react\\src\\components\\Board.js":"4","C:\\Users\\Devesh\\Documents\\React_Projects\\pathfinding-visualizer-react\\src\\components\\Node.jsx":"5","C:\\Users\\Devesh\\Documents\\React_Projects\\pathfinding-visualizer-react\\src\\store\\configureStore.js":"6","C:\\Users\\Devesh\\Documents\\React_Projects\\pathfinding-visualizer-react\\src\\store\\Node.js":"7","C:\\Users\\Devesh\\Documents\\React_Projects\\pathfinding-visualizer-react\\src\\utils\\nodeHelpers.js":"8","C:\\Users\\Devesh\\Documents\\React_Projects\\pathfinding-visualizer-react\\src\\algorithms\\Dijkstras(Basic).js":"9","C:\\Users\\Devesh\\Documents\\React_Projects\\pathfinding-visualizer-react\\src\\store\\Controls.js":"10","C:\\Users\\Devesh\\Documents\\React_Projects\\pathfinding-visualizer-react\\src\\algorithms\\Dijkstra.js":"11"},{"size":611,"mtime":1608817456167,"results":"12","hashOfConfig":"13"},{"size":362,"mtime":499162500000,"results":"14","hashOfConfig":"13"},{"size":177,"mtime":1609770166092,"results":"15","hashOfConfig":"13"},{"size":1861,"mtime":1610191905496,"results":"16","hashOfConfig":"13"},{"size":3290,"mtime":1610288405146,"results":"17","hashOfConfig":"13"},{"size":428,"mtime":1609844175785,"results":"18","hashOfConfig":"13"},{"size":3608,"mtime":1610288405216,"results":"19","hashOfConfig":"13"},{"size":1476,"mtime":1608903362354,"results":"20","hashOfConfig":"13"},{"size":2402,"mtime":1609689082947,"results":"21","hashOfConfig":"13"},{"size":505,"mtime":1609828788829,"results":"22","hashOfConfig":"13"},{"size":3662,"mtime":1610004916367,"results":"23","hashOfConfig":"13"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},"fakngb",{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33","usedDeprecatedRules":"26"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"43"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50","usedDeprecatedRules":"26"},"C:\\Users\\Devesh\\Documents\\React_Projects\\pathfinding-visualizer-react\\src\\index.js",[],["51","52"],"C:\\Users\\Devesh\\Documents\\React_Projects\\pathfinding-visualizer-react\\src\\reportWebVitals.js",[],"C:\\Users\\Devesh\\Documents\\React_Projects\\pathfinding-visualizer-react\\src\\App.js",[],"C:\\Users\\Devesh\\Documents\\React_Projects\\pathfinding-visualizer-react\\src\\components\\Board.js",["53","54","55","56","57","58"],"// This file contains the board and the nodes rendering.\r\n\r\nimport React, { useEffect, useState } from \"react\";\r\nimport \"../styles/Board.scss\";\r\nimport Node from \"./Node\";\r\nimport { useSelector, useDispatch } from \"react-redux\";\r\nimport { Dijkstra } from \"../algorithms/Dijkstra\";\r\nimport { visitNode, makePath, updateGrid } from \"../store/Node\";\r\n\r\nconst Board = () => {\r\n  const dispatch = useDispatch();\r\n\r\n  const {\r\n    grid,\r\n    START_NODE_ROW,\r\n    START_NODE_COL,\r\n    FINISH_NODE_ROW,\r\n    FINISH_NODE_COL,\r\n  } = useSelector((state) => state.nodes);\r\n\r\n  const newGrid = grid.slice();\r\n  const [localGrid, setLocalGrid] = useState(newGrid);\r\n\r\n  const { isMousePressed } = useSelector((state) => state.controls);\r\n\r\n  const dijkstraHandler = () => {\r\n    const { visited, result } = Dijkstra(\r\n      grid, // => global to local\r\n      START_NODE_ROW,\r\n      START_NODE_COL,\r\n      FINISH_NODE_ROW,\r\n      FINISH_NODE_COL\r\n    );\r\n\r\n    if (result.length === null || undefined) {\r\n      console.log(\"NO PATH FOUND\");\r\n    } else {\r\n      dispatch(makePath(result));\r\n    }\r\n\r\n    console.log(result);\r\n    // dispatch(visitNode(visited));\r\n  };\r\n\r\n  return (\r\n    <div className=\"grid\">\r\n      <button onClick={() => dijkstraHandler()}>\r\n        Visualize Dijkstra's Algorithm\r\n      </button>\r\n      {localGrid.map((row, rowIdx) => {\r\n        // => global to local\r\n        return (\r\n          <div key={rowIdx} className=\"grid-row\">\r\n            {row.map((node, nodeIdx) => {\r\n              const { row, col } = node;\r\n\r\n              return (\r\n                <Node\r\n                  key={nodeIdx}\r\n                  row={row}\r\n                  col={col}\r\n                  coordinate={[[row], [col]]}\r\n                />\r\n              );\r\n            })}\r\n          </div>\r\n        );\r\n      })}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Board;\r\n","C:\\Users\\Devesh\\Documents\\React_Projects\\pathfinding-visualizer-react\\src\\components\\Node.jsx",["59","60","61","62"],"// TODO after implementing the algorithms: Make a local state here with useState and store all the changes to the grid in that local state. We will only dispatch once when user clicks to run the algorithm. We will dispatch the local grid state and push it to the global state then perform the algorithm.\r\n\r\n// Not sure if this will improve performance but we need to see.\r\n\r\n// We shouldn't be able to change the global grid state from the screen.\r\n\r\n// We won't pull anything directly from the global state\r\n\r\n// If it lags even a little bit then we can put a small loading gif till the algorithm starts.\r\n\r\nimport React, { useState, useEffect } from \"react\";\r\n\r\nimport \"../styles/Node.scss\";\r\n\r\n// Redux\r\n\r\nimport { useSelector, useDispatch } from \"react-redux\";\r\n\r\n// Importing Actions\r\nimport {\r\n  makeWall,\r\n  breakWall,\r\n  updateGrid,\r\n  makeMultipleWalls,\r\n  breakMultipleWalls,\r\n} from \"../store/Node\";\r\nimport { mousePressed, mouseNotPressed } from \"../store/Controls\";\r\n\r\n// TODO: Find a new data structure for the walledNodes that prevents duplicate values.\r\nlet walledNodes = [];\r\n\r\nlet deleteWalledNodes = [];\r\n\r\nconst Node = ({ col, row, coordinate }) => {\r\n  // Pulling from global state\r\n  const { grid } = useSelector((state) => state.nodes);\r\n  const { isMousePressed } = useSelector((state) => state.controls);\r\n  // Constants\r\n  const GLOBAL_NODE = grid[row][col];\r\n  const dispatch = useDispatch();\r\n  // Local State\r\n  const [wallClass, setWallClass] = useState(false);\r\n\r\n  const createWall = () => {\r\n    if (!GLOBAL_NODE.isStart && !GLOBAL_NODE.isEnd && !GLOBAL_NODE.isWall) {\r\n      walledNodes.push([row, col]);\r\n      setWallClass(true);\r\n    }\r\n  };\r\n\r\n  const destroyWall = () => {\r\n    if (!GLOBAL_NODE.isStart && !GLOBAL_NODE.isEnd && GLOBAL_NODE.isWall) {\r\n      setWallClass(false);\r\n    }\r\n  };\r\n\r\n  const handleMouseDown = (row, col) => {\r\n    dispatch(mousePressed());\r\n    if (!wallClass) {\r\n      createWall();\r\n    }\r\n    if (wallClass) {\r\n      dispatch(breakWall({ row, col }));\r\n      setWallClass(false);\r\n      // destroyWall();\r\n    }\r\n  };\r\n\r\n  const handleMouseEnter = (row, col) => {\r\n    if (isMousePressed && !wallClass) {\r\n      createWall();\r\n    }\r\n    if (isMousePressed && wallClass) {\r\n      setWallClass(false);\r\n      deleteWalledNodes.push([row, col]);\r\n    }\r\n  };\r\n\r\n  const handleMouseUp = () => {\r\n    dispatch(mouseNotPressed());\r\n\r\n    dispatch(makeMultipleWalls(walledNodes));\r\n    walledNodes = [];\r\n    dispatch(breakMultipleWalls(deleteWalledNodes));\r\n    deleteWalledNodes = [];\r\n  };\r\n\r\n  // const singleNode = localGrid[row][col];\r\n  // TODO: Refactor this part to rely on the state directly\r\n\r\n  const extraClassName = wallClass\r\n    ? \"node-wall\"\r\n    : GLOBAL_NODE.isStart\r\n    ? \"node-start\"\r\n    : GLOBAL_NODE.isEnd\r\n    ? \"node-end\"\r\n    : GLOBAL_NODE.isVisited\r\n    ? \"node-visited\"\r\n    : GLOBAL_NODE.isPath\r\n    ? \"node-shortest-path\"\r\n    : \"\";\r\n  return (\r\n    <div\r\n      id={`node-${row}-${col}`}\r\n      className={`node ${extraClassName}`}\r\n      onMouseDown={(e) => handleMouseDown(row, col)}\r\n      onContextMenu={(e) => {\r\n        e.preventDefault();\r\n      }}\r\n      onMouseEnter={(e) => handleMouseEnter(row, col)}\r\n      onMouseUp={() => handleMouseUp()}></div>\r\n  );\r\n};\r\n\r\nexport default Node;\r\n","C:\\Users\\Devesh\\Documents\\React_Projects\\pathfinding-visualizer-react\\src\\store\\configureStore.js",[],"C:\\Users\\Devesh\\Documents\\React_Projects\\pathfinding-visualizer-react\\src\\store\\Node.js",["63"],"C:\\Users\\Devesh\\Documents\\React_Projects\\pathfinding-visualizer-react\\src\\utils\\nodeHelpers.js",[],["64","65"],"C:\\Users\\Devesh\\Documents\\React_Projects\\pathfinding-visualizer-react\\src\\algorithms\\Dijkstras(Basic).js",[],"C:\\Users\\Devesh\\Documents\\React_Projects\\pathfinding-visualizer-react\\src\\store\\Controls.js",[],"C:\\Users\\Devesh\\Documents\\React_Projects\\pathfinding-visualizer-react\\src\\algorithms\\Dijkstra.js",["66","67"],"import { useSelector, useDispatch } from \"react-redux\";\r\n\r\n// export default function Dijkstra(nodes, startNode, endNode) {\r\n//   return basicAStar(nodes, startNode, endNode, dijkstraHeuristic);\r\n// }\r\n\r\nexport const Dijkstra = (\r\n  grid,\r\n  START_NODE_ROW,\r\n  START_NODE_COL,\r\n  FINISH_NODE_ROW,\r\n  FINISH_NODE_COL\r\n) => {\r\n  // console.log(grid);\r\n  const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n  const endNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n\r\n  // console.log(startNode, endNode);\r\n\r\n  const neighbors = (node1, node2) => {\r\n    const xDistance = Math.abs(node1.row - node2.row);\r\n    const yDistance = Math.abs(node1.col - node2.col);\r\n    return xDistance + yDistance === 1;\r\n  };\r\n\r\n  const dijkstraHeuristic = {\r\n    comparer: (a, b) => a.distanceFromStart - b.distanceFromStart,\r\n    addHeuristics: (grid, startNode, endNode) =>\r\n      grid.map((girdNode) => ({\r\n        ...girdNode,\r\n        distanceFromStart: girdNode.isStart ? 0 : Infinity, // either 0 or infinity\r\n        previousNode: null,\r\n        // console.log()\r\n      })),\r\n    map: (currentNode, testedNode) => {\r\n      const calculatedDistance = currentNode.distanceFromStart + 1;\r\n\r\n      // console.log(currentNode);\r\n      return neighbors(currentNode, testedNode)\r\n        ? {\r\n            ...testedNode,\r\n            distanceFromStart: Math.min(\r\n              testedNode.distanceFromStart,\r\n              calculatedDistance\r\n            ),\r\n            previousNode:\r\n              testedNode.distanceFromStart > calculatedDistance\r\n                ? currentNode\r\n                : testedNode.previousNode,\r\n          }\r\n        : testedNode;\r\n    },\r\n    endCondition: (currentNode) => currentNode.distanceFromStart === Infinity,\r\n  };\r\n\r\n  const basicAStar = (grid, startNode, endNode, heuristic) => {\r\n    const visited = [];\r\n\r\n    const flatNodes = grid.flat().filter((gridNode) => !gridNode.isWall);\r\n    // console.log(flatNodes);\r\n    let unvisited = heuristic.addHeuristics(flatNodes, startNode, endNode);\r\n\r\n    for (let i = 0; unvisited.length !== 0; i++) {\r\n      unvisited.sort(heuristic.comparer);\r\n      const currentNode = unvisited[0];\r\n\r\n      // if lowest distance from start node in unvisited array equals Infinity\r\n      // it means there is no path from start to end, so we can end searching\r\n      if (heuristic.endCondition(currentNode)) {\r\n        return { visited, result: null };\r\n      }\r\n\r\n      unvisited.shift(); //remove current node\r\n      unvisited = unvisited.map((node) => heuristic.map(currentNode, node));\r\n\r\n      visited.push({ ...currentNode, visitedIndex: i });\r\n      if (currentNode.isEnd) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    const result = [];\r\n    const endNodeData = visited.find((n) => n.isEnd);\r\n    console.log(endNodeData);\r\n    // endNodeData contains an object that contains it's previous node. That previous node contains it's previous node and soo on until it gets to the startNode\r\n\r\n    for (\r\n      let node = endNodeData.previousNode, i = 0;\r\n      node.isStart !== true; // we will continue the loop until there is a node.isStart that is true\r\n      node = node.previousNode, i++\r\n    ) {\r\n      // If there no more nodes left then return visited and result otherwise keep pushing the nodes in the result array\r\n      //--------------------------------------\r\n\r\n      result.push({ ...node, visitedIndex: i });\r\n      // console.log(result);\r\n      if (!node) {\r\n        return { visited, result };\r\n      }\r\n    }\r\n\r\n    console.log(result);\r\n\r\n    //\r\n    return { visited, result };\r\n  };\r\n\r\n  // Main Return Statement\r\n  return basicAStar(grid, startNode, endNode, dijkstraHeuristic);\r\n};\r\n",{"ruleId":"68","replacedBy":"69"},{"ruleId":"70","replacedBy":"71"},{"ruleId":"72","severity":1,"message":"73","line":3,"column":17,"nodeType":"74","messageId":"75","endLine":3,"endColumn":26},{"ruleId":"72","severity":1,"message":"76","line":8,"column":10,"nodeType":"74","messageId":"75","endLine":8,"endColumn":19},{"ruleId":"72","severity":1,"message":"77","line":8,"column":31,"nodeType":"74","messageId":"75","endLine":8,"endColumn":41},{"ruleId":"72","severity":1,"message":"78","line":22,"column":21,"nodeType":"74","messageId":"75","endLine":22,"endColumn":33},{"ruleId":"72","severity":1,"message":"79","line":24,"column":11,"nodeType":"74","messageId":"75","endLine":24,"endColumn":25},{"ruleId":"72","severity":1,"message":"80","line":27,"column":13,"nodeType":"74","messageId":"75","endLine":27,"endColumn":20},{"ruleId":"72","severity":1,"message":"73","line":11,"column":27,"nodeType":"74","messageId":"75","endLine":11,"endColumn":36},{"ruleId":"72","severity":1,"message":"81","line":21,"column":3,"nodeType":"74","messageId":"75","endLine":21,"endColumn":11},{"ruleId":"72","severity":1,"message":"77","line":23,"column":3,"nodeType":"74","messageId":"75","endLine":23,"endColumn":13},{"ruleId":"72","severity":1,"message":"82","line":51,"column":9,"nodeType":"74","messageId":"75","endLine":51,"endColumn":20},{"ruleId":"72","severity":1,"message":"83","line":6,"column":10,"nodeType":"74","messageId":"75","endLine":6,"endColumn":25},{"ruleId":"68","replacedBy":"84"},{"ruleId":"70","replacedBy":"85"},{"ruleId":"72","severity":1,"message":"86","line":1,"column":10,"nodeType":"74","messageId":"75","endLine":1,"endColumn":21},{"ruleId":"72","severity":1,"message":"87","line":1,"column":23,"nodeType":"74","messageId":"75","endLine":1,"endColumn":34},"no-native-reassign",["88"],"no-negated-in-lhs",["89"],"no-unused-vars","'useEffect' is defined but never used.","Identifier","unusedVar","'visitNode' is defined but never used.","'updateGrid' is defined but never used.","'setLocalGrid' is assigned a value but never used.","'isMousePressed' is assigned a value but never used.","'visited' is assigned a value but never used.","'makeWall' is defined but never used.","'destroyWall' is assigned a value but never used.","'combineReducers' is defined but never used.",["88"],["89"],"'useSelector' is defined but never used.","'useDispatch' is defined but never used.","no-global-assign","no-unsafe-negation"]